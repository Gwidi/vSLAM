import rclpy
from rclpy.node import Node
from std_msgs.msg import Float64MultiArray
from geometry_msgs.msg import Vector3
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.animation as animation
import threading

class Subscriber(Node):
    def __init__(self):
        super().__init__('matlab_subscriber')

        # Subskrypcja do topica macierz_trans, nazwa topica taka sama jak Matlab, odbiera macierz transformacji A
        self.trans_subscription = self.create_subscription(Float64MultiArray, 'macierz_trans', self.matrix_callback, 10)

        # Subskrypcja do topica xyz_data, nazwa ma być taka sama jak w Matlab, odbiera współrzędne kolejnych punktów chmury 
        self.xyz_subscription = self.create_subscription(Float64MultiArray, 'xyz_data1', self.xyz_callback, 10)

        # Inicjalizacja list do gromadzenia danych
        self.transformed_points = []
        self.xyz_points = []

        # Inicjalizacja punktu początkowego do camPoses, w Matlabie też jest do [0,0,0]
        self.point = np.array([0, 0, 0, 1])

        self.get_logger().info('Subskrybent gotowy do odbierania danych')

    # Funkcja do zapisu danych wysłanych przez Matlaba
    def matrix_callback(self, msg):
        data = np.array(msg.data)
        if len(data) % 16 != 0:
            self.get_logger().error(f"Received data size is not a multiple of 16: {len(data)}")
            return

        num_matrices = len(data) // 16
        for i in range(num_matrices):
            matrix = data[i*16:(i+1)*16].reshape((4, 4))  # Pobierz macierz 4x4
            self.get_logger().info(f"Odebrana macierz:\n{matrix}")
            #print(f"Odebrana macierz:\n{matrix}")  # Wyświetlanie macierzy w terminalu
            transformed_point = matrix @ self.point.T  # Mnożenie macierzy przez transpozycję wektora
            self.transformed_points.append(transformed_point[:3])  # Gromadzenie współrzędnych punktu położenia camPoses
            self.get_logger().info(f'Nowe współrzędne punktu: {transformed_point[:3]}')

    def xyz_callback(self, msg):
        data = np.array(msg.data)
        self.get_logger().info(f"Received xyz data: {data}")
        if data.size % 3 != 0:
            self.get_logger().error(f"Received data size is not a multiple of 3: {data.size}")
            return
        
        data = data.reshape(-1, 3)  # Przekształcenie wektora na Nx3
        self.xyz_points.extend(data)  # Dodanie punktów do listy
        for point in data:
            self.get_logger().info(f'Otrzymano - x: {point[0]}, y: {point[1]}, z: {point[2]}')

    # Funkcja do usunięcia węzła
    def destroy_node(self):
        super().destroy_node()
        self.get_logger().info('Subskrybent został zamknięty')

    def get_data(self):
        transformed_data = np.array(self.transformed_points)
        xyz_data = np.array(self.xyz_points)
        return transformed_data, xyz_data

# Funkcja main, utworzenie obiektu klasy 
def main(args=None):
    rclpy.init(args=args)
    matlab_subscriber = Subscriber()

    def ros_spin():
        rclpy.spin(matlab_subscriber)

    # Uruchomienie ROS2 wątku
    ros_thread = threading.Thread(target=ros_spin)
    ros_thread.start()

    fig = plt.figure()
    ax = fig.add_subplot(111, projection='3d')
    ax.set_xlim([-2, 2])
    ax.set_ylim([-2, 2])
    ax.set_zlim([-2, 2])

    # Inicjalizacja linii ruchu kamery, kolor czerwony
    line, = ax.plot([], [], [], color='red', lw=2)

    # Inicjalizacja wykresu punktów mapy, s=... zmniejsza rozmiar punktów
    scat = ax.scatter([], [], [], s=0.01)

    def animate(i):
        transformed_data, xyz_data = matlab_subscriber.get_data()
        if transformed_data.size > 0:
            line.set_data(transformed_data[:, 0], transformed_data[:, 1])
            line.set_3d_properties(transformed_data[:, 2])
        if xyz_data.size > 0:
            scat._offsets3d = (xyz_data[:, 0], xyz_data[:, 1], xyz_data[:, 2])
        plt.draw()

    ani = animation.FuncAnimation(fig, animate, interval=100)
    plt.show()

    matlab_subscriber.destroy_node()
    rclpy.shutdown()
    ros_thread.join()

if __name__ == '__main__':
    main()